@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│                             ASM Notes                                       │
@│ GCC Assembler                                                               │
@└─────────────────────────────────────────────────────────────────────────────┘  

@Bit=1, Nibble = 4bits, Byte = 8bits, Halfword = 16bits, Word = 32bits, Doubleword = 64bits*/

@ Almost every ARM instruction can be executed conditionally on the state of the ALU status flags in the Current Program Status Register (CPSR). Refer to Table 2.1 for a list of the suffixes to add to instructions to make them conditional.
@ Table 2.1 http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/ch02s05s02.html
@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Table 4.2./2.1 ARM condition codes                                      │
@├─────────────────────────────────────────────────────────────────────────┤
@│ Suffix  Flags                           Meaning                         │
@│ EQ      Z set                           Equal                           │
@│ NE      Z clear                         Not equal                       │
@│ CS/HS   C set                           Higher or same (unsigned >= )   │
@│ CC/LO   C clear                         Lower (unsigned < )             │
@│ MI      N set                           Negative. Set when 31bit is set │ 31 bit of destination register is set
@│ PL      N clear                         Positive or zero                │
@│ VS      V set                           Overflow                        │
@│ VC      V clear                         No overflow                     │
@│ HI      C set and Z clear               Higher (unsigned > )            │ Ex: cmp r10, r5; movhi r10, #0; if r10 > r5 then r10 = 0
@│ LS      C clear or Z set                Lower or same (unsigned <= )    │
@│ GE      N and V the same                Signed >=                       │
@│ LT      N and V different               Signed <                        │
@│ GT      Z clear, and N and V the same   Signed >                        │
@│ LE      Z set, or N and V different     Signed <=                       │
@│ AL      Any Always                      (usually omitted)               │
@│ NV      Never                                                           │
@└─────────────────────────────────────────────────────────────────────────┘

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│      Twos complemen            │
@└────────────────────────────────┘
@ To represent a negative number in binary use twos complement. To represent a -3
@ in binary first take the binary value for 3
@ 1. 0000 0011 (3b)
@ 2. 1111 1100 Invert the bits (Ones complement)
@ 3. 0000 0001 Add one to it.
@    1111 1101 You get twos complement -3


@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ARM User Mode Registers Bank    │
@└────────────────────────────────┘
@┍━━━━━━━━━━━━━━━━━━━┑
@├───────────────────┤
@│ R0 │ Available    │
@├───────────────────┤
@│ R1 │ Available    │
@├───────────────────┤
@│ R2 │ Available    │
@├───────────────────┤
@│ R3 │ Available    │
@├───────────────────┤
@│ R4 │ Available    │
@├───────────────────┤
@│ R5 │ Available    │
@├───────────────────┤
@│ R6 │ Available    │
@├───────────────────┤
@│ R7 │ Available    │
@├───────────────────┤
@│ R8 │ Available    │
@├───────────────────┤
@│ R9 │ Available    │
@├───────────────────┤
@│ R10│ Available    │
@├───────────────────┤
@│ R11│ Available    │
@├───────────────────┤
@│ R12│ Available    │ ip
@├───────────────────┤
@│ R13│ stack pntr   │ sp
@├───────────────────┤
@│ R14│ Link registe │ lr
@├───────────────────┤
@│ R15│ Program Cntr │ pc
@├───────────────────┤
@│ Current program   │ cpsr
@│ Status register   │
@└───────────────────┘

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│Status Register Configuration   │
@└────────────────────────────────┘
 ┌─────────────────────────────────────┐
@│31│30│29│28│27..24..8│7│6│5│4│3│2│1│0│
@├─────────────────────────────────────┤
@│N │Z │C │V │   │ J │ │I│F│T│ Mode    │
@└─────────────────────────────────────┘
@ N = Negative flag
@ Z = Zero flag
@ C = Carry flag
@ V = Overflow flag
@ I = Interupt disable bits
@ F = Interupt disable bits
@ T = Processor states 
@ J = Jazelle State. Allow running of a Java Virtual Machine
@ Mode = processor mode. Usually user mode

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ARM Instructions                │
@└────────────────────────────────┘
ldr r1, [r5,#1]   @ load register. load contents at location in r5 +1 byte
ldr r1, [r5, #-1]
ldr r1, [r5, -r1]
ldr r1, [r5, r2, lsr #2] @ r2 is shifted by 4 and added to the address in r5
                         @ memory is addressed in bytes. A word is 4 bytes, and register holds one word. So if you want to move to the next word in memory you have to shift your address by #2. Or this moves  you 4 bytes. Each shift is 2 bytes. In this case 2 bytes * 2 shifts = 4 bytes or one word. this  moves you on a word boundry
ldr r1,[r5]      @ load contents at location in r5 into r1

mvn r1, r2       @ Performs a bitwise logical NOT on operatnd 2 (r2) and places the result into op1 (r1)

str r1,[r6]      @ store to memory. Store content r1 in location r6. 
                 @[rX] is called an addressing mode. ARM instructions have several addressing modes.
pc               @ Program counter nmeomonic. = r15
beq              @ Branch if EQual. Jump to some label if Z flag = 1
bne              @ Branch if Not Equal. Jump to some label if Z flag = 0
                 @ mnemonic that allow us to test the Status Register Flag Z
cmp <op1>,<op2>  @ CoMPare. Performs a notational subtraction. op1 - op2. The physical result of the subtraction is ignored, but it updates the Status Register flags according to the outcome of the subtraction, which will be postive, zero, or negative (there can never be a carry). If the result of the subtraction was 0 Zero flag would be set. op1 is always a register. op2 can be a register or a specific or a immediate value.
                 @ Example: 
                    cmp r0, r1
                    beq zeroflagset  @Branch to the label 'zeroflagset'.
cmn <op1>,<op2>  @ ComPare Negative.
                 @ cmp and cpn are the only instrctions that directly affect the condition of the Status Register. By default, the rest of the ARM instruction set does not update the Status Register.
sub r0,r0,r1     @ subtract r1 from r0 store in r0
rsb r0,r0,r1     @ Reverse subtract. r1 - r0
rsc r0,r0,r1     @ Reverse subtract with carry

@S Suffix. ARM provides a method of allowing an operation such as sub to update the Status Register. This is done by use the Set suffix. All we have to do is append 'S' to the end of the mnemonix we want to use to modify the flags.
@      Example:
       subs r0, r0, r1   @This subtracts the contents of r1 from r0 leaving the result in r0 and at the same time updating the flags in the Status register.
b                @ Branch to a label

smull (<suffix>) <destLo>, <destHi>, <Op1>, <Op2>  @ Signed multiplication using 2 32-bit registers
                                                   @ op1 and op2 are assumed to be in twos complement form
umull (<suffix>) <destLo>, <destHi>, <Op1>, <Op2>  @ Unsigned multiplication using 2 32-bit registers

smlal            @ are the signed and unsigned equivalents of MLA. Op1 and Op2 are multiplied together and the result is added to any value already in destLo and destHi
umala

smlaxy           @ permits multiplication with accumulates using 16bit operands with a 32-bit accumulator.
SMLA<x><y>(<suffix>)<dest>, <Op1>, <Op2>, <Op3> 
                 @ Here <x> and <y> can be either B or T which stand for Bootom and Top, referring to the bottom or top two bytes of Operand1 and Operand2 respectivly. Operand3 contains the value to be added to the result of the multiplicatoin of the bytes identified in Operand1 and Operand2.
                 @ Example:
                 @    SMLABTCC R0, R1, R2, R3
                 @ If the Carry is clear (CC) then the low half-word of R1 will be multiplied with the top half-word of R2. The result will be added to the value in R3 and the result stored in R0.

SMLAWy           @ Here the bottom half-word of R6 is multiplied with the full word in R5 and the value in R7 is added to the result, which is dropped into R0.

SMUAD<X>(<suffic>) <dest>, <Op1>, <Op2>
SMUSD<X>(<suffic>) <dest>, <Op1>, <Op2>           
                 @ work on 16-bit values and offer Signed Multiply with Addition and Singed Multiply with Subtraction, allowing optional exchange of operand halves. 
                 @ If 'X' is included in the instruction then the most and least significant half-words of Operand2 are exchanged. If 'X' is ommitted then no exchange takes place. The instruction then multiplies the contents of the two lower half-words of Op1 and Op2 and aves the result, and then multiplies the contents of the two upper half-words of the operands and saves the results.
                 @ SMUAD (Dual Signed 16-bit Multiply and Addition) the two paritial products are then added and the result placed in the destination register.
                 @ SMUAS (Dual Signed 16-bit Multiply with Subtraction) the second partial product (the upper half-word) is subtracted from the first partial product.
                 @ Example
                 @    SMUADXEQ R5, R6, R7
                 @    SMUDS R5, R7, R9

VLDR             @ For loading floats
                 @ Examples:
                 @    VLDR d2, [r5,#4] @ Laod d2 with a F64 value
                 @    VLDR s1, [r5]    @ Load s1 with F32 value
VSTR
VCMP             @ Vector compare
                 @ There is two version .F32 and .F64
                 @ Example: 
                 @   VCMP .F32 s0, s1  @s0 - s1, set flags
VMRS APSR_nzcv, FPSCR @ Moves the Floating point Status and Control Register (FPSCR) into the Application Status Reigster (APSR - CPSR)
                      @  FPSCR can alse be transfered to an ARM register.
                      @    VMRS r4, FPSCR
                      @ The FPSCR can be loaded with the contents of an ARM register allowing bits to be pre-determined and set:
                      @     VMSR FPSCR, r4  @ Copy r4 into FPSCR
MRS              @ transfers the contents of either CPSR or SPSR into a register.
                 @  Syntax:
                 @      MRS (<suffix>) <Op1>, <CSPR|SPSR>
MSR              @ transfer the contents of a register into either the CSPR or SPSR
                 @  Syntax:
                 @      MSR <CSPR|SPSR|Flags>, <Op1>

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Vector Floating Point          │
@└────────────────────────────────┘
VLDR             @ Vector load register
VCVT             @ Vector convert. Convert from single to double percision or vis versa
    VCVT.F64.F32 @ Convert to F64 from F32. Source and destination registers should match the converting sizes given
VMOCV            @ Vector move

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Shifts and Rotates             │
@└────────────────────────────────┘
Three types of shifts:
    Logical: Logically shifting a number left to right by one position has the effect of doubleing it or halving it. By increasing the number of logical shifts you can multiply and divide numbers accordingly.
    Arithimetic: In an arithmetical shift the sign bit is preserved. Ensures that division is performed correctly for both positive and negative numbers.
    Rotate Right: Rotate Right (ROR) moves the bits out from the low end and feeds them straight back in the high end. The last bit rotated out is also copied into the Carry Flag as well as being rotated around.
    Rotate Extended: Cannot specify the number of movements it only shifts right once. The carry flag value is dropped into b31 and the value of b0 is put into the carry flag. Pretty much a 32bit shift right
@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Mnemonic  │  Meaning                 │
@├──────────────────────────────────────┤
@│   LSL     │ Logical shift left       │
@│   LSR     │ Logical shift right      │
@│   ASL     │ Arithimetic shift left   │
@│   ASR     │ Arithimetic shift right  │
@│   ROR     │ Rotate right             │
@│   RRX     │ Rotate Right with eXtend │
@└──────────────────────────────────────┘

Logical shift left: bit b31 drops into the carry flag
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b31 │ b30 │ b29  │ b28 │ b27 │ b26 │ ... │ b2 │ b1 │ b0 │ 0  │
@└───────────────────────────────────────────────────────────────────────┘

Logical shift right: Bit b0 drops off into the carry flag
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │  0  │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘

Arithmeticl shift right: Bit b0 drops off into the carry flag
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │ b31 │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘

Rotation Right
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │ b0  │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘

Rotation Right Extended
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │  x  │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘



@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Immediate Constany Range       │
@└────────────────────────────────┘
Immediates only have 12bits to represnt them. 0000 0000 0000.
The 12-bit field is split into two, one part of 8bits xxxx 0000 0000 and one part 4-bits 0000 xxxx xxxx.
The 8-bit field is used to represent a numeric constant. The 4-bit field one of 16 different positions (them selves then shifted by two) which the 8-bit value may be rotated to through an even number of positions.

Examples:
Using 173 as immediiate constant, in binary this is:
00000000 00000000 00000000 10101101
The value can be presented in 8-bits, so no shift is required and the position bits will be set to 0.

Examine the number 19,968. In binary this is:
00000000 00000000 01001110 00000000

If we compare this to the patterns in Figure below, we can see this as the value placed at position 12. To create this number as an immediate operand we would use 78 (01001110) and rotated it right by 24.

Bit31                           Bit0  Position  ROR
++++++++ ++++++++ ++++++++ 76543210   0         0
10++++++ ++++++++ ++++++++ ++765432   1         2
3210++++ ++++++++ ++++++++ ++++7654   2         4
543210++ ++++++++ ++++++++ ++++++76   3         6
76543210 ++++++++ ++++++++ ++++++++   4         8
++765432 10++++++ ++++++++ ++++++++   5         10
++++7654 3210++++ ++++++++ ++++++++   6         12
++++++76 543210++ ++++++++ ++++++++   7         14
++++++++ 76543210 ++++++++ ++++++++   8         16
++++++++ ++765432 10++++++ ++++++++   9         18
++++++++ ++++7654 3210++++ ++++++++   10        20
++++++++ ++++++76 543210++ ++++++++   11        22
++++++++ ++++++++ 76543210 ++++++++   12        24
++++++++ ++++++++ ++765432 10++++++   13        26
++++++++ ++++++++ ++++7654 3210++++   14        28
++++++++ ++++++++ ++++++76 543210++   15        30

This provides us with the second way that an immediate operand can be specified as a shifted operand, and this takes the format shown:
Instruction (<Suffic>) <Op1>, <Op2>, <Op3>, <Shift>
Example:
mov r0, r1, ror #24 @ store in r0, r1 right rotated by 24

Of course, we can use all these values directly as immediate constants as the assembler will resolve them directly for us. 
mov r0, #19968

It is the values that cannot be calculated in this way through fig above that are the issue.

Although 257 cannot be used as an immediate constant, it can be created by storing 256 in a register then adding 1.

add r0, r1, #257 @ Invalid constant error

mov r2, #256
add r2, r2, #1
add r0, r1, r2   @add 257 to r1 put it in r0

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Multiplication by Constants    │
@└────────────────────────────────┘
            n= 1,2,3,4
To multiply by 2,4,8,16.. 2^n; 
mov r0, r0, lsl #n
            n= 1,2,3,4
To multiply by 3,5,9,17 ... (2^n)+1; 
add r0, r0, r0, lsl #n
            n= 1,2,3,4
To multiply by 1,3,7,15... (2^n)-1
rsb r0, r0, r0, lsl #n

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ ADR Directive                  │
@└────────────────────────────────┘
adr <register>, <label>    
    ADR is a directive not an ARM instruction. It is part of the assembler. Does address calculation for you
    1. Notes the address of where the instruction is being assembled
    2. Notes the address of the specified label
    3. Calculates the offset between the two memory positions.
    Can only access references in the .text (executable) section of your code.

.word directive. Allows you to store a word (4 bytes) into memory.
LDR r0, =string
       can access memory across the board. Not restricted to .text sections

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Address Write Back             │
@└────────────────────────────────┘
! used for write back
LDR r0, [r1,r2]!    @ with the ! the calcualted address r1+r2 is stored back into r1.
                    @ this could be used for looping through an array a word at a time by LDR r0, [r1,#4]!

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Post-Indexed Addressing        │
@└────────────────────────────────┘
Post-indexed addressing uses the write back feature by default. 
LDR (<suffix>) <destination>, [<Op1>], <Opt2>
Examples:
    LDR r0,[r1],r2
    STR r3, [r4], #4
    LDRB r6,[r1],r5,LSL #1   @ load a byte
When post-indexed addressing is used, the contents of the base regiter alone are taken as the source or destination address. Only after the memory has been extracted or deposited are the contents of the offset field (Opt2) added to the base registrer and the value written to the base register.
This means say for 
LDR r0, [r1], #8
That the value at location r1 is first loaded into r0 and then 8 is added to r1 and the sum is stored in r1.

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Block Transfer                 │
@└────────────────────────────────┘
Transfer or load more than one register at a time.
LDM <Options>(<Suffix>) <Op1>(!), {<Comma separted list of registers, or a range of registers separated by a ->}
STM <Options>(<Suffix>) <Op1>(!), {<Comma separted list of registers, or a range of registers separated by a ->}
    Registers can be listed in any order and a range of registers can be speciified with the use of a hyphen r5-r9
    Operand1: 
        is a register which contains the address marking the start of memory to be used in the operation. This address is not changed unless the write back operator ! is used in the instruction
    reglist:
        is a list of registers to be loaded or stored, enclosed in braces. It can conatin register ranges. It must be comma separated if it contains more than on register or register range.
    Example:
        STM r0, {r1, r5-r8}
You can control the direction of the storage and wether the pointer is increased before or after the transfer.

    @┌────────────────────────────┐
    @│ Suffix │ Meaning           │
    @├────────────────────────────┤
    @│ IA     │ Increment After   │  Increment: Address + 4b * n; where n is the position
    @│ IB     │ Increment Before  │
    @│ DA     │ Decrement After   │  Decrement: Address - 4b * n;
    @│ DB     │ Decrement Before  │
    @└────────────────────────────┘

Before or after means, stay for STMIA, store the value first then increment the pointer. STMIB means, first increment the pointer then store the data.
Unless Write Back is asked for, the address in the specified register Op1 remains unaltered. The address calculated after the last register in the list has been processed.

One good use of STMIA is saving and restoring register state.
STMIA r0, {r1-r14}
LDMDA r0, {r1-r14}

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Stacks                         │
@└────────────────────────────────┘
By default the ARM implements a full descending stack if a format is not specified.
Stacks can use the above table of IA, IB etc. but ARM also gives you postfixes for stacks

    @┌──────────────────────────────────┐
    @│ Postfix │ Meaning                │
    @├──────────────────────────────────┤
    @│ FA      │ Full Ascending stack   │
    @│ FD      │ Full Decending stack   │
    @│ EA      │ Empty Ascending Stack  │
    @│ ED      │ Empty Descending Stack │
    @└──────────────────────────────────┘

Full Ascending stack: means the stack gross with increasing address, and the stack pointer points to a cell with a value in it. Points to the last occupied address on the stack
Full Decending stack: means the stack gross with decreasing addresses, and the stack pointer points to a cell with a value in it. Indecates the next avaiable space
Empty Ascending stack: means the stack grows with increasing address, and the stack pointer points to a cell with no value in it.
Empty Descending stack: means teh stack grows with decreasing addresses, an the stack pointer points to a cell with no value ini it.
    @┌────────────────────────────────────────────┐
    @│ Instruction Pair │ Stack Type              │
    @├────────────────────────────────────────────┤
    @│ STMFD / LDMFD    │ Full Descending stack   │
    @│ STMFA / LDMFA    │ Full Ascending Stack    │
    @│ STMED / LDMED    │ Empty Descending Stack  │
    @│ STMEA / LDMEA    │ Empty Ascending Stack   │
    @└────────────────────────────────────────────┘

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Directives                     │
@└────────────────────────────────┘
.ascii ""
.asciz ""

.word 0xFFFFFFFF, 0xFF  @Store four-btye values, separated by commas into memory.

.byte 1,2,3,4  @comma separated list of numbers in the range of 0 to 255. Store byte sized values, separated by commas into memory.

.equ variableName, <value>  @kind of like defining variables. Assign immediate value to named label. Example: .equ one, 1   or one equ 1

.align <number>  @ If you store data in the .text section of your program, then it must start on a word boundary. If you insert text or data that does not completely fill the space to a four-byte boundary then the assembler will issue an error message. "Unalgined opcodes detected in executable segment". Use align to pad the program.

You can use labels to mark the beginning and end of an array of bytes
    Example:
        values:
            .byte 1,2,3,4,5,6,7,8,9
        endvalues:
Then just load the address of values into a register and endvalues into another, increment the first address until it equals the second.

.float
.req      @ The register equate directive maps a symbol to a register. Its a bit like using a define statement in C. I use them all the time because it makes the source just that much easier to read.
                Example: li .req r0  @ mapped the symbol lo to r0. 
.rept <n>  @ Repeat directive repeats a block of code terminated by .endr n times.

PUSH
POP
VPUSH
VPOP    @Vector pop for double percision numbers
@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Creating Functions             │
@└────────────────────────────────┘

    @┌────────────────────────────────────────────────────┐
    @│ Register │      Role                │  Contents    │ 
    @│          │                          │  Preservered │
    @├────────────────────────────────────────────────────┤
    @│    r0    │  Argument and Result     │   No         │
    @│    r1    │        Argument          │   No         │
    @│    r2    │        Argument          │   No         │
    @│    r3    │        Argument          │   No         │
    @│    r4    │        General           │   Yes        │
    @│    r5    │        General           │   Yes        │
    @│    r6    │        General           │   Yes        │
    @│    r7    │        General           │   Yes        │
    @│    r8    │        General           │   Yes        │
    @│    r9    │        General           │   Yes        │
    @│    r10   │        General           │   Yes        │
    @│    r11   │        General           │   Yes        │
    @│    r12   │        General           │   Yes        │
    @│    LR    │     Return Address       │   No         │
    @│    SP    │     Stack Pointer        │   Yes        │
    @└────────────────────────────────────────────────────┘

Chart above details the purpose of each register when a function is called. In summary a function should adhere to the following:
    It may freely modify registers r0, r1, r2, r3 and expect to find the information in them that it requires to carry out it's task.
    It can modify registers r4-12, providing it restores their calues before returning to the calling routine.
    It can modify the Stack Pointer providing it restores the value held on entry.
    It must presever the address in the Link Register so that it may return correctly to the calling program. 
    It should make no assumptions as to the contents of the CPSR. As far as the function is concerned the status of the N, Z, C and V falgs are unknown.


@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Vector Floating Point (VFP)    │
@└────────────────────────────────┘
Single percision floating point registers are s0-s31. They are one word wide. 
Double percision floating point registers are d0-d15. They are two words wide.
The registers are one and the same. So s0 and s1 can be used individually or combined as d0 for double percision.
Scalar banks s0-s7/d0-d3
Vectorial banks s8-s31/d4-d15

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ VFP Control Register           │
@└────────────────────────────────┘
FPSCR Floating point & Status Control Register
    @┌──────────────────────────────────────────────────────────────────────┐
    @│ FPSCR Format       │ Rd  │  │   │ │ Vector │  │ Exception │  │ CEB   │
    @├──────────────────────────────────────────────────────────────────────┤
    @│31│30│29│28       24│23│22│21│20 │ │18│17│16│  │ 12       7│  │4    0 │
    @├──────────────────────────────────────────────────────────────────────┤
    @│N │Z │C │V │ │ │ │  │Rmode│Stride│ │ Len    │  │ │ │ │ │ │ │  │ │ │ │ │
    @└──────────────────────────────────────────────────────────────────────┘
Register Function Summary
    @┌─────────────────────────────────────────────────────────────────────────────────┐
    @│ Bit   │ Flag Set              │  Detail                                         │ 
    @├─────────────────────────────────────────────────────────────────────────────────┤
    @│ 31-28 │  Condition Flags      │   Negative, Zero, Carry, Overflow               │
    @│ 23-22 │  Rounding Mode        │   Controls how values are rounded               │
    @│ 21-20 │  Stride               │   Controls the sttep size taken in vector banks │
    @│ 18-16 │  Len                  │   Controls the Vector length                    │
    @│ 12-8  │  Exception Status     │   Enables trapping of exception types.          │
    @│ 4-0   │  Cumulative Exception │   Trap cumulative exceptions                    │
    @└─────────────────────────────────────────────────────────────────────────────────┘
APSR (Application Program Status Register - CPSR)

Condition code comparisoin ARM vs VFP

    @┌──────────────────────────────────────────────────────────────┐
    @│ Mnemonic │ Meaning after ARM inst.  │Detail                  │ 
    @├──────────────────────────────────────────────────────────────┤
    @│ EQ      │ Equal                     │ Equal                  │
    @│ NE      │ Not equal                 │ No equal, or unordered │
    @│ CS      │ Carry set                 │ >=, or unordered       │
    @│ HS      │ Unsigned higher or same   │ >=, or unordered       │
    @│ CC      │ Carry clear               │ <                      │
    @│ LO      │ Unsigned lower            │ <                      │
    @│ MI      │ Negative                  │ <                      │
    @│ PL      │ Positive or zero          │ >=, or unordered       │
    @│ VS      │ Overflow                  │ Unordered              │
    @│ VC      │ No overflow               │ Not unordered          │
    @│ HI      │ Unsigned Higher           │ > or unordered         │
    @│ LS      │ Unsigned Lower or same    │ < or equal             │
    @│ GE      │ Signed >=                 │ >=                     │
    @│ LT      │ Signed <                  │ < or unordered         │
    @│ GT      │ Signed >                  │ >                      │
    @│ LE      │ Signed <=                 │ <= or unordered        │
    @│ AL      │ Always                    │ Always                 │
    @└──────────────────────────────────────────────────────────────┘

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Exception Handling             │
@└────────────────────────────────┘
IRQ: Interrupt Rquest Mode. is deemed to be lower priority where a slight delay will not create any problems.
FIQ: Fast Interrupt Mode. THese are interrupts deemed to be ones that have highest priority and are the ones that must be serviced first.

    @┌──────────────────────────────────────────────────────────────────────────────────┐
    @│ Mode                │ Description                                                │ 
    @├──────────────────────────────────────────────────────────────────────────────────┤
    @│ FIQ                 │ Entered when a high priority (fast) interrupt is raised    │
    @│ IRQ                 │ Entered when a low priority (normal) interrupt is raised   │
    @│ Supervisor and Rest │ Entered on reset and when a Software Interrupt is executed │
    @│ Abort               │ Used to handle memort access violations                    │
    @│ Undef               │ Used to handle undefined insstructions                     │
    @│ User                │ Unprivileged mode under which most task run                │
    @└──────────────────────────────────────────────────────────────────────────────────┘

    @ Bit settings for Mode changes in CPSR
    @┌────────────────────────────────────────────┐
    @│              I   F   T        Mode         │ 
    @│              7   6   5   4   3   2   1   0 │
    @├────────────────────────────────────────────┤
    @│ Abort      │ 1 │ 1 │ 0 │ 1 │ 0 │ 1 │ 1 │ 1 │
    @│ FIQ        │ 1 │ 1 │ 0 │ 1 │ 0 │ 0 │ 0 │ 1 │
    @│ IRQ        │ 1 │ uc│ 0 │ 1 │ 0 │ 0 │ 1 │ 0 │
    @│ Supervisor │ 1 │ uc│ 0 │ 1 │ 0 │ 0 │ 1 │ 1 │
    @│ System     │ 1 │ 1 │ 0 │ 1 │ 1 │ 1 │ 1 │ 1 │
    @│ Undefined  │ 1 │ uc│ 0 │ 1 │ 1 │ 0 │ 1 │ 1 │
    @│ User       │ 0 │ 0 │ 0 │ 1 │ 0 │ 0 │ 0 │ 0 │
    @└────────────────────────────────────────────┘

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Vectors                        │
@└────────────────────────────────┘
A Vector is a known location in memorty that is exactly one word, or 32-bits wide. (Not to be confused with vectors in VFP.)
There are two types of vectors: hardware vectors and software vectors. Hardware vectors are hardwired to the ARM chip itself and they never change, and are located at the very beginning of memory.
In Raspbain, the vector table can be located at a higher address in memory, here starting at 0x0FFFF0000.
Hardware vectors control the ultimate flow of information and are a set of memory addresses that are 'known' to the ARM chip. The term 'known' here means that they are physically 'hard-wared' and are thus hardware vectors.
Hardware vectos typically control the flow of abnormal events which the chip itself cannnot deal with. They are often referred to as exception vectors and they reside at the start of memory map from 0x00000000 to 0x0000001C. 
    @ Hardware Vectors
    @┌────────────────────────────────────────────────────┐
    @│ Address    │ Hi Address │ Vector                   │ 
    @├────────────────────────────────────────────────────┤
    @│ 0x00000000 │ 0xFFFF0000 │ ARM reset                │
    @│ 0x00000004 │ 0xFFFF0004 │ Undefiend Instruction    │
    @│ 0x00000008 │ 0xFFFF0008 │ Software Interrupt (SWI) │
    @│ 0x0000000C │ 0xFFFF000C │ Abort (pre-fetch)        │
    @│ 0x00000010 │ 0xFFFF0010 │ Abort (pre-fetch)        │
    @│ 0x00000014 │ 0xFFFF0014 │ Address exceptoin        │
    @│ 0x00000018 │ 0xFFFF0018 │ IRQ                      │
    @│ 0x0000001C │ 0xFFFF001C │ FIRQ ( or FIQ)           │
    @└────────────────────────────────────────────────────┘

One common reason for manipulating the hardware vectors is to change the machine's response to memory access faults. If some non-existent memory is accessed then one of the memory fault vectors, 0x0000000C to 0x00000014, is called.
The normal effect of this is for the Operating System to report a fatal error and stop exceuting the current task. You could change this to just warn the user.

When an exception interrupt occurs the processor stops what it is doing and jumps to the appropriate location in the vector table. Each location contains a branc instruction pointing to the start of a specific handling routine.
These instructions normally take one of three forms as shown below

    @┌─────────────────────────────────────────────────────────────┐
    @│ Instruction           │ Description                         │ 
    @├─────────────────────────────────────────────────────────────┤
    @│ B <address>           │ Jump to an address gven as a        │
    @│                       │ relative                            │
    @│                       │ offset in to the PC.                │
    @│ LDR pc, [pc, #offset] │ Load address from memory to         │
    @│                       │ the PC. This address is a 32-bit    │
    @│                       │ value stored close to the vector    │
    @│                       │ table. This is slightly slower than │
    @│                       │ the previous method due to extra    │
    @│                       │ memory access. The bonus is that    │
    @│                       │ you can branch to any address in    │ 
    @│                       │ the memory map.                     │
    @│ LDR pc, [pc, #-0xFF0] │ Load address of a specific          │
    @│                       │ interrupt service routine from      │ 
    @│                       │ 0xFFFFF030 to the PC.               │
    @│ MOV pc, #value        │ Copies an immediate value into the  │
    @│                       │ PC. This will normally be a single  │
    @│                       │ byte value that is rotated right by │
    @│                       │ an even number of bits. Thus        │
    @│                       │ provides access to the full momory  │
    @│                       │ map but with gaps.                  │
    @└─────────────────────────────────────────────────────────────┘
