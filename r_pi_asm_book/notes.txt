@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│                             ASM Notes                                       │
@│ GCC Assembler                                                               │
@└─────────────────────────────────────────────────────────────────────────────┘  

@Bit=1, Nibble = 4bits, Byte = 8bits, Halfword = 16bits, Word = 32bits, Doubleword = 64bits*/

@ Almost every ARM instruction can be executed conditionally on the state of the ALU status flags in the Current Program Status Register (CPSR). Refer to Table 2.1 for a list of the suffixes to add to instructions to make them conditional.
@ Table 2.1 http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/ch02s05s02.html
@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Table 4.2./2.1 ARM condition codes                                      │
@├─────────────────────────────────────────────────────────────────────────┤
@│ Suffix  Flags                           Meaning                         │
@│ EQ      Z set                           Equal                           │
@│ NE      Z clear                         Not equal                       │
@│ CS/HS   C set                           Higher or same (unsigned >= )   │
@│ CC/LO   C clear                         Lower (unsigned < )             │
@│ MI      N set                           Negative. Set when 31bit is set │ 31 bit of destination register is set
@│ PL      N clear                         Positive or zero                │
@│ VS      V set                           Overflow                        │
@│ VC      V clear                         No overflow                     │
@│ HI      C set and Z clear               Higher (unsigned > )            │ Ex: cmp r10, r5; movhi r10, #0; if r10 > r5 then r10 = 0
@│ LS      C clear or Z set                Lower or same (unsigned <= )    │
@│ GE      N and V the same                Signed >=                       │
@│ LT      N and V different               Signed <                        │
@│ GT      Z clear, and N and V the same   Signed >                        │
@│ LE      Z set, or N and V different     Signed <=                       │
@│ AL      Any Always                      (usually omitted)               │
@│ NV      Never                                                           │
@└─────────────────────────────────────────────────────────────────────────┘

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│      Twos complemen            │
@└────────────────────────────────┘
@ To represent a negative number in binary use twos complement. To represent a -3
@ in binary first take the binary value for 3
@ 1. 0000 0011 (3b)
@ 2. 1111 1100 Invert the bits (Ones complement)
@ 3. 0000 0001 Add one to it.
@    1111 1101 You get twos complement -3


@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ARM User Mode Registers Bank    │
@└────────────────────────────────┘
@┍━━━━━━━━━━━━━━━━━━━┑
@├───────────────────┤
@│ R0 │ Available    │
@├───────────────────┤
@│ R1 │ Available    │
@├───────────────────┤
@│ R2 │ Available    │
@├───────────────────┤
@│ R3 │ Available    │
@├───────────────────┤
@│ R4 │ Available    │
@├───────────────────┤
@│ R5 │ Available    │
@├───────────────────┤
@│ R6 │ Available    │
@├───────────────────┤
@│ R7 │ Available    │
@├───────────────────┤
@│ R8 │ Available    │
@├───────────────────┤
@│ R9 │ Available    │
@├───────────────────┤
@│ R10│ Available    │
@├───────────────────┤
@│ R11│ Available    │
@├───────────────────┤
@│ R12│ Available    │
@├───────────────────┤
@│ R13│ stack pntr   │
@├───────────────────┤
@│ R14│ Link registe │
@├───────────────────┤
@│ R15│ Program Cntr │
@├───────────────────┤
@│ Current program   │
@│ Status register   │
@└───────────────────┘

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│Status Register Configuration   │
@└────────────────────────────────┘
 ┌──────────────────────────────────┐
@│31│30│29│28│27...8│7│6│5│4│3│2│1│0│
@├──────────────────────────────────┤
@│N │Z │C │V │      │I│F│T│ Mode    │
@└──────────────────────────────────┘
@ N = Negative flag
@ Z = Zero flag
@ C = Carry flag
@ V = Overflow flag
@ I = Interupt disable bits
@ F = Interupt disable bits
@ T = Processor states 
@ Mode = processor mode. Usually user mode

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ARM Instructions                │
@└────────────────────────────────┘
ldr r1,[r5,#1]   @ load register. load contents at location in r5 +1 byte
ldr r1,[r5]      @ load contents at location in r5
str r1,[r6]      @ store to memory. Store content r1 in location r6. 
@[rX] is called an addressing mode. ARM instructions have several addressing modes.
pc               @ Program counter nmeomonic. = r15
beq              @ Branch if EQual. Jump to some label if Z flag = 1
bne              @ Branch if Not Equal. Jump to some label if Z flag = 0
                 @ mnemonic that allow us to test the Status Register Flag Z
cmp <op1>,<op2>  @ CoMPare. Performs a notational subtraction. op1 - op2. The physical result of the subtraction is ignored, but it updates the Status Register flags according to the outcome of the subtraction, which will be postive, zero, or negative (there can never be a carry). If the result of the subtraction was 0 Zero flag would be set. op1 is always a register. op2 can be a register or a specific or a immediate value.
                 @ Example: 
                    cmp r0, r1
                    beq zeroflagset  @Branch to the label 'zeroflagset'.
cmn <op1>,<op2>  @ ComPare Negative.
                 @ cmp and cpn are the only instrctions that directly affect the condition of the Status Register. By default, the rest of the ARM instruction set does not update the Status Register.
sub r0,r0,r1     @ subtract r1 from r0 store in r0

@S Suffix. ARM provides a method of allowing an operation such as sub to update the Status Register. This is done by use the Set suffix. All we have to do is append 'S' to the end of the mnemonix we want to use to modify the flags.
@      Example:
       subs r0, r0, r1   @This subtracts the contents of r1 from r0 leaving the result in r0 and at the same time updating the flags in the Status register.
b                @ Branch to a label



@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Shifts and Rotates             │
@└────────────────────────────────┘
Three types of shifts:
    Logical: Logically shifting a number left to right by one position has the effect of doubleing it or halving it. By increasing the number of logical shifts you can multiply and divide numbers accordingly.
    Arithimetic: In an arithmetical shift the sign bit is preserved. Ensures that division is performed correctly for both positive and negative numbers.
    Rotate Right: Rotate Right (ROR) moves the bits out from the low end and feeds them straight back in the high end. The last bit rotated out is also copied into the Carry Flag as well as being rotated around.
    Rotate Extended: Cannot specify the number of movements it only shifts right once. The carry flag value is dropped into b31 and the value of b0 is put into the carry flag. Pretty much a 32bit shift right
@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Mnemonic  │  Meaning                 │
@├──────────────────────────────────────┤
@│   LSL     │ Logical shift left       │
@│   LSR     │ Logical shift right      │
@│   ASL     │ Arithimetic shift left   │
@│   ASR     │ Arithimetic shift right  │
@│   ROR     │ Rotate right             │
@│   RRX     │ Rotate Right with eXtend │
@└──────────────────────────────────────┘

Logical shift left: bit b31 drops into the carry flag
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b31 │ b30 │ b29  │ b28 │ b27 │ b26 │ ... │ b2 │ b1 │ b0 │ 0  │
@└───────────────────────────────────────────────────────────────────────┘

Logical shift right: Bit b0 drops off into the carry flag
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │  0  │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘

Arithmeticl shift right: Bit b0 drops off into the carry flag
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │ b31 │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘

Rotation Right
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │ b0  │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘

Rotation Right Extended
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │  x  │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘



@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Immediate Constany Range       │
@└────────────────────────────────┘
Immediates only have 12bits to represnt them. 0000 0000 0000.
The 12-bit field is split into two, one part of 8bits xxxx 0000 0000 and one part 4-bits 0000 xxxx xxxx.
The 8-bit field is used to represent a numeric constant. The 4-bit field one of 16 different positions (them selves then shifted by two) which the 8-bit value may be rotated to through an even number of positions.

Examples:
Using 173 as immediiate constant, in binary this is:
00000000 00000000 00000000 10101101
The value can be presented in 8-bits, so no shift is required and the position bits will be set to 0.

Examine the number 19,968. In binary this is:
00000000 00000000 01001110 00000000

If we compare this to the patterns in Figure below, we can see this as the value placed at position 12. To create this number as an immediate operand we would use 78 (01001110) and rotated it right by 24.

Bit31                           Bit0  Position  ROR
++++++++ ++++++++ ++++++++ 76543210   0         0
10++++++ ++++++++ ++++++++ ++765432   1         2
3210++++ ++++++++ ++++++++ ++++7654   2         4
543210++ ++++++++ ++++++++ ++++++76   3         6
76543210 ++++++++ ++++++++ ++++++++   4         8
++765432 10++++++ ++++++++ ++++++++   5         10
++++7654 3210++++ ++++++++ ++++++++   6         12
++++++76 543210++ ++++++++ ++++++++   7         14
++++++++ 76543210 ++++++++ ++++++++   8         16
++++++++ ++765432 10++++++ ++++++++   9         18
++++++++ ++++7654 3210++++ ++++++++   10        20
++++++++ ++++++76 543210++ ++++++++   11        22
++++++++ ++++++++ 76543210 ++++++++   12        24
++++++++ ++++++++ ++765432 10++++++   13        26
++++++++ ++++++++ ++++7654 3210++++   14        28
++++++++ ++++++++ ++++++76 543210++   15        30

This provides us with the second way that an immediate operand can be specified as a shifted operand, and this takes the format shown:
Instruction (<Suffic>) <Op1>, <Op2>, <Op3>, <Shift>
Example:
mov r0, r1, ror #24 @ store in r0, r1 right rotated by 24

Of course, we can use all these values directly as immediate constants as the assembler will resolve them directly for us. 
mov r0, #19968

It is the values that cannot be calculated in this way through fig above that are the issue.

Although 257 cannot be used as an immediate constant, it can be created by storing 256 in a register then adding 1.

add r0, r1, #257 @ Invalid constant error

mov r2, #256
add r2, r2, #1
add r0, r1, r2   @add 257 to r1 put it in r0



