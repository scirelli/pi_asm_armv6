@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│                             ASM Notes                                       │
@│ GCC Assembler                                                               │
@└─────────────────────────────────────────────────────────────────────────────┘  

@Bit=1, Nibble = 4bits, Byte = 8bits, Halfword = 16bits, Word = 32bits, Doubleword = 64bits*/

@ Almost every ARM instruction can be executed conditionally on the state of the ALU status flags in the Current Program Status Register (CPSR). Refer to Table 2.1 for a list of the suffixes to add to instructions to make them conditional.
@ Table 2.1 http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/ch02s05s02.html
@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Table 4.2./2.1 ARM condition codes                                      │
@├─────────────────────────────────────────────────────────────────────────┤
@│ Suffix  Flags                           Meaning                         │
@│ EQ      Z set                           Equal                           │
@│ NE      Z clear                         Not equal                       │
@│ CS/HS   C set                           Higher or same (unsigned >= )   │
@│ CC/LO   C clear                         Lower (unsigned < )             │
@│ MI      N set                           Negative. Set when 31bit is set │ 31 bit of destination register is set
@│ PL      N clear                         Positive or zero                │
@│ VS      V set                           Overflow                        │
@│ VC      V clear                         No overflow                     │
@│ HI      C set and Z clear               Higher (unsigned > )            │ Ex: cmp r10, r5; movhi r10, #0; if r10 > r5 then r10 = 0
@│ LS      C clear or Z set                Lower or same (unsigned <= )    │
@│ GE      N and V the same                Signed >=                       │
@│ LT      N and V different               Signed <                        │
@│ GT      Z clear, and N and V the same   Signed >                        │
@│ LE      Z set, or N and V different     Signed <=                       │
@│ AL      Any Always                      (usually omitted)               │
@│ NV      Never                                                           │
@└─────────────────────────────────────────────────────────────────────────┘

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│      Twos complemen            │
@└────────────────────────────────┘
@ To represent a negative number in binary use twos complement. To represent a -3
@ in binary first take the binary value for 3
@ 1. 0000 0011 (3b)
@ 2. 1111 1100 Invert the bits (Ones complement)
@ 3. 0000 0001 Add one to it.
@    1111 1101 You get twos complement -3


@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ARM User Mode Registers Bank    │
@└────────────────────────────────┘
@┍━━━━━━━━━━━━━━━━━━━┑
@├───────────────────┤
@│ R0 │ Available    │
@├───────────────────┤
@│ R1 │ Available    │
@├───────────────────┤
@│ R2 │ Available    │
@├───────────────────┤
@│ R3 │ Available    │
@├───────────────────┤
@│ R4 │ Available    │
@├───────────────────┤
@│ R5 │ Available    │
@├───────────────────┤
@│ R6 │ Available    │
@├───────────────────┤
@│ R7 │ Available    │
@├───────────────────┤
@│ R8 │ Available    │
@├───────────────────┤
@│ R9 │ Available    │
@├───────────────────┤
@│ R10│ Available    │
@├───────────────────┤
@│ R11│ Available    │
@├───────────────────┤
@│ R12│ Available    │
@├───────────────────┤
@│ R13│ stack pntr   │
@├───────────────────┤
@│ R14│ Link registe │
@├───────────────────┤
@│ R15│ Program Cntr │
@├───────────────────┤
@│ Current program   │
@│ Status register   │
@└───────────────────┘

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│Status Register Configuration   │
@└────────────────────────────────┘
 ┌──────────────────────────────────┐
@│31│30│29│28│27...8│7│6│5│4│3│2│1│0│
@├──────────────────────────────────┤
@│N │Z │C │V │      │I│F│T│ Mode    │
@└──────────────────────────────────┘
@ N = Negative flag
@ Z = Zero flag
@ C = Carry flag
@ V = Overflow flag
@ I = Interupt disable bits
@ F = Interupt disable bits
@ T = Processor states 
@ Mode = processor mode. Usually user mode

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ARM Instructions                │
@└────────────────────────────────┘
ldr r1, [r5,#1]   @ load register. load contents at location in r5 +1 byte
ldr r1, [r5, #-1]
ldr r1, [r5, -r1]
ldr r1, [r5, r2, lsr #2] @ r2 is shifted by 4 and added to the address in r5
                         @ memory is addressed in bytes. A word is 4 bytes, and register holds one word. So if you want to move to the next word in memory you have to shift your address by #2. Or this moves  you 4 bytes. Each shift is 2 bytes. In this case 2 bytes * 2 shifts = 4 bytes or one word. this  moves you on a word boundry
ldr r1,[r5]      @ load contents at location in r5
str r1,[r6]      @ store to memory. Store content r1 in location r6. 
@[rX] is called an addressing mode. ARM instructions have several addressing modes.
pc               @ Program counter nmeomonic. = r15
beq              @ Branch if EQual. Jump to some label if Z flag = 1
bne              @ Branch if Not Equal. Jump to some label if Z flag = 0
                 @ mnemonic that allow us to test the Status Register Flag Z
cmp <op1>,<op2>  @ CoMPare. Performs a notational subtraction. op1 - op2. The physical result of the subtraction is ignored, but it updates the Status Register flags according to the outcome of the subtraction, which will be postive, zero, or negative (there can never be a carry). If the result of the subtraction was 0 Zero flag would be set. op1 is always a register. op2 can be a register or a specific or a immediate value.
                 @ Example: 
                    cmp r0, r1
                    beq zeroflagset  @Branch to the label 'zeroflagset'.
cmn <op1>,<op2>  @ ComPare Negative.
                 @ cmp and cpn are the only instrctions that directly affect the condition of the Status Register. By default, the rest of the ARM instruction set does not update the Status Register.
sub r0,r0,r1     @ subtract r1 from r0 store in r0

@S Suffix. ARM provides a method of allowing an operation such as sub to update the Status Register. This is done by use the Set suffix. All we have to do is append 'S' to the end of the mnemonix we want to use to modify the flags.
@      Example:
       subs r0, r0, r1   @This subtracts the contents of r1 from r0 leaving the result in r0 and at the same time updating the flags in the Status register.
b                @ Branch to a label

smull (<suffix>) <destLo>, <destHi>, <Op1>, <Op2>  @ Signed multiplication using 2 32-bit registers
                                                   @ op1 and op2 are assumed to be in twos complement form
umull (<suffix>) <destLo>, <destHi>, <Op1>, <Op2>  @ Unsigned multiplication using 2 32-bit registers

smlal            @ are the signed and unsigned equivalents of MLA. Op1 and Op2 are multiplied together and the result is added to any value already in destLo and destHi
umala

smlaxy           @ permits multiplication with accumulates using 16bit operands with a 32-bit accumulator.
SMLA<x><y>(<suffix>)<dest>, <Op1>, <Op2>, <Op3> 
                 @ Here <x> and <y> can be either B or T which stand for Bootom and Top, referring to the bottom or top two bytes of Operand1 and Operand2 respectivly. Operand3 contains the value to be added to the result of the multiplicatoin of the bytes identified in Operand1 and Operand2.
                 @ Example:
                 @    SMLABTCC R0, R1, R2, R3
                 @ If the Carry is clear (CC) then the low half-word of R1 will be multiplied with the top half-word of R2. The result will be added to the value in R3 and the result stored in R0.

SMLAWy           @ Here the bottom half-word of R6 is multiplied with the full word in R5 and the value in R7 is added to the result, which is dropped into R0.

SMUAD<X>(<suffic>) <dest>, <Op1>, <Op2>
SMUSD<X>(<suffic>) <dest>, <Op1>, <Op2>           
                 @ work on 16-bit values and offer Signed Multiply with Addition and Singed Multiply with Subtraction, allowing optional exchange of operand halves. 
                 @ If 'X' is included in the instruction then the most and least significant half-words of Operand2 are exchanged. If 'X' is ommitted then no exchange takes place. The instruction then multiplies the contents of the two lower half-words of Op1 and Op2 and aves the result, and then multiplies the contents of the two upper half-words of the operands and saves the results.
                 @ SMUAD (Dual Signed 16-bit Multiply and Addition) the two paritial products are then added and the result placed in the destination register.
                 @ SMUAS (Dual Signed 16-bit Multiply with Subtraction) the second partial product (the upper half-word) is subtracted from the first partial product.
                 @ Example
                 @    SMUADXEQ R5, R6, R7
                 @    SMUDS R5, R7, R9



@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Shifts and Rotates             │
@└────────────────────────────────┘
Three types of shifts:
    Logical: Logically shifting a number left to right by one position has the effect of doubleing it or halving it. By increasing the number of logical shifts you can multiply and divide numbers accordingly.
    Arithimetic: In an arithmetical shift the sign bit is preserved. Ensures that division is performed correctly for both positive and negative numbers.
    Rotate Right: Rotate Right (ROR) moves the bits out from the low end and feeds them straight back in the high end. The last bit rotated out is also copied into the Carry Flag as well as being rotated around.
    Rotate Extended: Cannot specify the number of movements it only shifts right once. The carry flag value is dropped into b31 and the value of b0 is put into the carry flag. Pretty much a 32bit shift right
@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Mnemonic  │  Meaning                 │
@├──────────────────────────────────────┤
@│   LSL     │ Logical shift left       │
@│   LSR     │ Logical shift right      │
@│   ASL     │ Arithimetic shift left   │
@│   ASR     │ Arithimetic shift right  │
@│   ROR     │ Rotate right             │
@│   RRX     │ Rotate Right with eXtend │
@└──────────────────────────────────────┘

Logical shift left: bit b31 drops into the carry flag
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b31 │ b30 │ b29  │ b28 │ b27 │ b26 │ ... │ b2 │ b1 │ b0 │ 0  │
@└───────────────────────────────────────────────────────────────────────┘

Logical shift right: Bit b0 drops off into the carry flag
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │  0  │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘

Arithmeticl shift right: Bit b0 drops off into the carry flag
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │ b31 │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘

Rotation Right
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │ b0  │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘

Rotation Right Extended
@┌───────────────────────────────────────────────────────────────────────┐
@│ LSL    │ C   │           Word               │     │    │    │    │    │
@├───────────────────────────────────────────────────────────────────────┤
@│ Before │ x   │ b31 │ b30  │ b29 │ b28 │ b27 │ ... │ b3 │ b2 │ b1 │ b0 │
@│ After  │ b0  │  x  │ b31  │ b30 │ b29 │ b28 │ ... │ b4 │ b3 │ b2 │ b1 │
@└───────────────────────────────────────────────────────────────────────┘



@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Immediate Constany Range       │
@└────────────────────────────────┘
Immediates only have 12bits to represnt them. 0000 0000 0000.
The 12-bit field is split into two, one part of 8bits xxxx 0000 0000 and one part 4-bits 0000 xxxx xxxx.
The 8-bit field is used to represent a numeric constant. The 4-bit field one of 16 different positions (them selves then shifted by two) which the 8-bit value may be rotated to through an even number of positions.

Examples:
Using 173 as immediiate constant, in binary this is:
00000000 00000000 00000000 10101101
The value can be presented in 8-bits, so no shift is required and the position bits will be set to 0.

Examine the number 19,968. In binary this is:
00000000 00000000 01001110 00000000

If we compare this to the patterns in Figure below, we can see this as the value placed at position 12. To create this number as an immediate operand we would use 78 (01001110) and rotated it right by 24.

Bit31                           Bit0  Position  ROR
++++++++ ++++++++ ++++++++ 76543210   0         0
10++++++ ++++++++ ++++++++ ++765432   1         2
3210++++ ++++++++ ++++++++ ++++7654   2         4
543210++ ++++++++ ++++++++ ++++++76   3         6
76543210 ++++++++ ++++++++ ++++++++   4         8
++765432 10++++++ ++++++++ ++++++++   5         10
++++7654 3210++++ ++++++++ ++++++++   6         12
++++++76 543210++ ++++++++ ++++++++   7         14
++++++++ 76543210 ++++++++ ++++++++   8         16
++++++++ ++765432 10++++++ ++++++++   9         18
++++++++ ++++7654 3210++++ ++++++++   10        20
++++++++ ++++++76 543210++ ++++++++   11        22
++++++++ ++++++++ 76543210 ++++++++   12        24
++++++++ ++++++++ ++765432 10++++++   13        26
++++++++ ++++++++ ++++7654 3210++++   14        28
++++++++ ++++++++ ++++++76 543210++   15        30

This provides us with the second way that an immediate operand can be specified as a shifted operand, and this takes the format shown:
Instruction (<Suffic>) <Op1>, <Op2>, <Op3>, <Shift>
Example:
mov r0, r1, ror #24 @ store in r0, r1 right rotated by 24

Of course, we can use all these values directly as immediate constants as the assembler will resolve them directly for us. 
mov r0, #19968

It is the values that cannot be calculated in this way through fig above that are the issue.

Although 257 cannot be used as an immediate constant, it can be created by storing 256 in a register then adding 1.

add r0, r1, #257 @ Invalid constant error

mov r2, #256
add r2, r2, #1
add r0, r1, r2   @add 257 to r1 put it in r0

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Multiplication by Constants    │
@└────────────────────────────────┘
            n= 1,2,3,4
To multiply by 2,4,8,16.. 2^n; 
mov r0, r0, lsl #n
            n= 1,2,3,4
To multiply by 3,5,9,17 ... (2^n)+1; 
add r0, r0, r0, lsl #n
            n= 1,2,3,4
To multiply by 1,3,7,15... (2^n)-1
rsb r0, r0, r0, lsl #n

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ ADR Directive                  │
@└────────────────────────────────┘
adr <register>, <label>    
    ADR is a directive not an ARM instruction. It is part of the assembler. Does address calculation for you
    1. Notes the address of where the instruction is being assembled
    2. Notes the address of the specified label
    3. Calculates the offset between the two memory positions.
    Can only access references in the .text (executable) section of your code.

.word directive. Allows you to store a word (4 bytes) into memory.
LDR r0, =string
       can access memory across the board. Not restricted to .text sections

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Address Write Back             │
@└────────────────────────────────┘
! used for write back
LDR r0, [r1,r2]!    @ with the ! the calcualted address r1+r2 is stored back into r1.
                    @ this could be used for looping through an array a word at a time by LDR r0, [r1,#4]

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Post-Indexed Addressing        │
@└────────────────────────────────┘
Post-indexed addressing uses the write back feature by default. 
LDR (<suffix>) <destination>, [<Op1>], <Opt2>
Examples:
    LDR r0,[r1],r2
    STR r3, [r4], #4
    LDRB r6,[r1],r5,LSL #1
When post-indexed addressing is used, the contents of the base regiter alone are taken as the source or destination address. Only after the memory has been extracted or deposited are the contents of the offset field (Opt2) added to the base registrer and the value written to the base register.
This means say for 
LDR r0, [r1], #8
That the value at location r1 is first loaded into r0 and then 8 is added to r1 and the sum is stored in r1.

@┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑
@│ Blocl Transfer                 │
@└────────────────────────────────┘
Transfer or load more than one register at a time.
LDM <Options>(<Suffix>) <Op1>(!), {<Comma separted list of registers, or a range of registers separated by a ->}
STM <Options>(<Suffix>) <Op1>(!), {<Comma separted list of registers, or a range of registers separated by a ->}
    Registers can be listed in any order and a range of registers can be speciified with the use of a hyphen r5-r9
    Operand1 is a register which contains the address marking the start of memory to be used in the operation. This address is not changed unless the write back operator ! is used in the instruction
    Example:
        STM r0, {r1, r5-r8}
You can control the direction of the storage and wether the pointer is increased before or after the transfer.

@┌────────────────────────────┐
@│ Suffix │ Meaning           │
@├────────────────────────────┤
@│ IA     │ Increment After   │  Increment: Address + 4b * n; where n is the position
@│ IB     │ Increment Before  │
@│ DA     │ Decrement After   │  Decrement: Address - 4b * n;
@│ DB     │ Decrement Before  │
@└────────────────────────────┘

Before or after means, stay for STMIA, store the value first then increment the pointer. STMIB means, first increment the pointer then store the data.
Unless Write Back is asked for, the address in the specified register Op1 remains unaltered. The address calculated after the last register in the list has been processed.

One good use of STMIA is saving and restoring register state.
STMIA r0, {r1-r14}
LDM   r0, {r1-r14}
